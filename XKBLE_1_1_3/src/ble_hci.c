#include "ble_hci.h"

struct hci_request ble_hci_request(uint16_t ocf, int clen, void * status, void * cparam)
{
	struct hci_request rq;
	memset(&rq, 0, sizeof(rq));
	rq.ogf = OGF_LE_CTL;
	rq.ocf = ocf;
	rq.cparam = cparam;
	rq.clen = clen;
	rq.rparam = status;
	rq.rlen = 1;
	return rq;
}

// Get HCI device.
int GetHciDevice(){
	const int device = hci_open_dev(hci_get_route(NULL));
	if ( device < 0 ) { 
		LOG_E("Getting HCI device","Failed to open HCI device.");
		exit(0);
		// return 0; 
	}
	return device;
}

// Set BLE scan parameters.
void SetBleScanParams(int device){
	int ret, status;
	le_set_scan_parameters_cp scan_params_cp;
	memset(&scan_params_cp, 0, sizeof(scan_params_cp));
	scan_params_cp.type 			= 0x00; 
	scan_params_cp.interval 		= htobs(0x0010);
	scan_params_cp.window 			= htobs(0x0010);
	scan_params_cp.own_bdaddr_type 	= 0x00; // Public Device Address (default).
	scan_params_cp.filter 			= 0x00; // Accept all.

	struct hci_request scan_params_rq = ble_hci_request(OCF_LE_SET_SCAN_PARAMETERS, LE_SET_SCAN_PARAMETERS_CP_SIZE, &status, &scan_params_cp);
	
	ret = hci_send_req(device, &scan_params_rq, 1000);
	if ( ret < 0 ) {
		hci_close_dev(device);
		LOG_E("Setting BLE scan parameters", "Failed to set scan parameters data.");
		exit(0);
		// return 0;
	}

}

// Set BLE events report mask.
void SetBleEventsReportMask(int device){
	int ret, status;
	le_set_event_mask_cp event_mask_cp;
	memset(&event_mask_cp, 0, sizeof(le_set_event_mask_cp));
	int i = 0;
	for ( i = 0 ; i < 8 ; i++ ) event_mask_cp.mask[i] = 0xFF;

	struct hci_request set_mask_rq = ble_hci_request(OCF_LE_SET_EVENT_MASK, LE_SET_EVENT_MASK_CP_SIZE, &status, &event_mask_cp);
	ret = hci_send_req(device, &set_mask_rq, 1000);
	if ( ret < 0 ) {
		hci_close_dev(device);
		LOG_E("Setting BLE events report mask", "Failed to set event mask.");
		exit(0);
		// return 0;
	}
}

// Enable scanning.
void EnableScanning(int device, le_set_scan_enable_cp * scan_cp_dest){
	int ret, status;
	le_set_scan_enable_cp scan_cp;
	memset(&scan_cp, 0, sizeof(scan_cp));
	scan_cp.enable 		= 0x01;	// Enable flag.
	scan_cp.filter_dup 	= 0x00; // Filtering disabled.

	struct hci_request enable_adv_rq = ble_hci_request(OCF_LE_SET_SCAN_ENABLE, LE_SET_SCAN_ENABLE_CP_SIZE, &status, &scan_cp);

	ret = hci_send_req(device, &enable_adv_rq, 1000);
	if ( ret < 0 ) {
		hci_close_dev(device);
		LOG_E("Enable scanning", "Failed to enable scan.");
		exit(0);
		// return 0;
	}
	memcpy(scan_cp_dest, &scan_cp, sizeof(scan_cp));
}

// Get Results.
void GetResults(int device){
	struct hci_filter nf;
	hci_filter_clear(&nf);
	hci_filter_set_ptype(HCI_EVENT_PKT, &nf);
	hci_filter_set_event(EVT_LE_META_EVENT, &nf);
	if ( setsockopt(device, SOL_HCI, HCI_FILTER, &nf, sizeof(nf)) < 0 ) {
		hci_close_dev(device);
		LOG_E("Getting Results", "Could not set socket options\n");
		exit(0);
		// return 0;
	}
}


// Disable scanning.
void DisableScanning(int device, le_set_scan_enable_cp * scan_cp_dest){
	int ret, status;
	memset(&scan_cp_dest, 0, sizeof(scan_cp_dest));
	scan_cp_dest->enable = 0x00;	// Disable flag.

	struct hci_request disable_adv_rq = ble_hci_request(OCF_LE_SET_SCAN_ENABLE, LE_SET_SCAN_ENABLE_CP_SIZE, &status, scan_cp_dest);
	ret = hci_send_req(device, &disable_adv_rq, 1000);
	if ( ret < 0 ) {
		hci_close_dev(device);
		perror("Failed to disable scan.");
		return 0;
	}

	hci_close_dev(device);
}
